/**
 * @file wifiHandler.cpp
 * @author Thomas Bittner
 * @brief Wifi handler is a wrapper for the arduino wifi function. This wrapper provides handling of wifi credetials and
 * storing it over reset.
 * @version 0.1
 * @date 2023-08-01
 * 
 * @copyright Copyright (c) 2023
 * 
 */

#include <WifiHandler.hpp>
#include <Preferences.h>
#include <WiFi.h>
#include <Settings.hpp>
#include "lvgl.h"

/*TODO: rework to not use global variables*/
//extern WifiHandler wifihandler;
//extern Preferences preferences;
//extern Display display;
//extern Settings settings;
//extern PubSubClient client;
const char* temporary_ssid;
const char* temporary_password;

WiFiClient espClient;

std::shared_ptr<WifiHandler> WifiHandler::mInstance = nullptr;
std::shared_ptr<WifiHandler> WifiHandler::getInstance() {
  if (mInstance) {
    return mInstance;
  }
  mInstance = std::shared_ptr<WifiHandler>(new WifiHandler());
  return mInstance;
};

// WiFi status event
//void WifiHandler::WiFiEvent(WiFiEvent_t event, WiFiEventInfo_t aEventInfo){
void WifiHandler::WiFiEvent(WiFiEvent_t event){
  LV_LOG_TRACE("WifiHandler::WifiEvent()");
  int no_networks = 0;
  switch (event)
  {
    case ARDUINO_EVENT_WIFI_SCAN_DONE:
      LV_LOG_TRACE("WIFI scan done");
      no_networks = WiFi.scanComplete();
      if (no_networks < 0)
      {
        LV_LOG_TRACE("Scan failed");
      }
      else
      {
        //settings.clear_wifi_networks();
        LV_LOG_TRACE("%d found", no_networks);
        //settings.wifi_scan_complete( no_networks);
      }
      break;
    case ARDUINO_EVENT_WIFI_STA_GOT_IP:
      //client.setServer(MQTT_SERVER, 1883); // MQTT initialization
      //client.connect("OMOTE"); â€š// Connect using a client id
      LV_LOG_TRACE("ARDUINO_EVENT_WIFI_STA_GOT_IP");
    case ARDUINO_EVENT_WIFI_STA_GOT_IP6:
      //settings.update_wifi(true);
      //wifihandler.update_credetials(temporary_ssid, temporary_password);
      WifiHandler::getInstance()->StoreCredentials();
      WiFi.setAutoConnect(true);
      WifiHandler::getInstance()->UpdateStatus();
      break;
    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
      LV_LOG_TRACE("ARDUINO_EVENT_WIFI_STA_DISCONNECTED");
      //settings.update_wifi(false);
      break;
    case ARDUINO_EVENT_WIFI_STA_LOST_IP:
      LV_LOG_TRACE("ARDUINO_EVENT_WIFI_STA_LOST_IP");
      //settings.update_wifi(false);
      break;
    case ARDUINO_EVENT_WIFI_STA_STOP:
      LV_LOG_TRACE("ARDUINO_EVENT_WIFI_STA_STOP");
      //settings.update_wifi(false);
      break;
    default:
      LV_LOG_TRACE("ARDUINO_EVENT_WIFI default");
      break;
  }
}

std::string WifiHandler::getFoundSSID(unsigned int index)
{
  LV_LOG_TRACE("WifiHandler::getFoundSSID()");
  return WiFi.SSID(index).c_str();
}

int WifiHandler::getFoundRSSI(unsigned int index)
{
  LV_LOG_TRACE("WifiHandler::getFoundRSSI()");
  return WiFi.RSSI(index);
}

/*
WifiHandler::WifiHandler()
{
    this->password[0] = '\0';
    this->SSID[0] = '\0';
}
*/

// void WifiHandler::update_credetials(const char* temporary_ssid, const char* temporary_password)
// {
//     if (strcmp(temporary_password, this->password) != 0 || strcmp(temporary_ssid, this->SSID) != 0)
//     {
//         strcpy(this->password, temporary_password);
//         strcpy(this->SSID, temporary_ssid);

//         preferences.putString("password", this->password);
//         preferences.putString("SSID", this->SSID);
//     }
// }
void WifiHandler::StoreCredentials() {
  // No connection was attempted so don't try to to save the creds
  if (!mIsConnectionAttempt) {
    return;
  }
  mPassword = mConnectionAttemptPassword;
  mSSID = mConnectionAttemptSSID;

  Preferences preferences;
  preferences.begin("WifiSettings", false);
  preferences.putString("password", mPassword.c_str());
  preferences.putString("SSID", mSSID.c_str());
  preferences.end();

  mConnectionAttemptPassword.clear();
  mConnectionAttemptSSID.clear();
  mIsConnectionAttempt = false;
}

void WifiHandler::scan()
{
    WiFi.setAutoReconnect(false);
    WiFi.scanNetworks(true);
}

void WifiHandler::UpdateStatus() {
  LV_LOG_TRACE("UpdateStatus");
  mCurrentStatus.isConnected = WiFi.isConnected();
  mCurrentStatus.IP = WiFi.localIP().toString().c_str();
  mCurrentStatus.ssid =
      mCurrentStatus.isConnected ? WiFi.SSID().c_str() : mConnectionAttemptSSID;

  mStatusUpdate->notify(mCurrentStatus);
}

void WifiHandler::setWiFiEvent(void *wifi_event_cb) {
  LV_LOG_TRACE("WiFi.onEvent() returned %d", WiFi.onEvent((WiFiEventCb)wifi_event_cb));
}

void WifiHandler::begin()
{
  LV_LOG_TRACE(">>> WifiHandler::begin()");
    WiFi.setHostname("OMOTE");
    WiFi.mode(WIFI_STA);
    //WiFi.onEvent(WiFiEvent);
    //LV_LOG_TRACE("WiFi.onEvent() returned %d", WiFi.onEvent(WiFiEvent));

    // Preferences preferences;
    // preferences.begin("wifiSettings", false);
    // String ssid = preferences.getString("SSID");
    // String password = preferences.getString("password");
    // bool wifiEnabled = preferences.getBool("enabled", false);
    // preferences.end();
    // LV_LOG_TRACE("ssid: \"%s\" (%d,%d), password: \"%s\"", ssid.c_str(), ssid.length(), ssid.isEmpty(), password.c_str());

    // /* If the SSID is not empty, there was a value stored in the preferences and we try to use it.*/
    // if (!ssid.empty())
    // {
    //     LV_LOG_TRACE("Connecting to wifi: %s", ssid);
    //     strcpy(this->SSID,  ssid.c_str());
    //     strcpy(this->password, password.c_str());
    //     LV_LOG_TRACE("this->SSID: \"%s\" (%d, %d), this->password: \"%s\"", this->SSID, std::string(this->SSID).length(), !(std::string(this->SSID).empty()), this->password);
    //     this->connect(this->SSID, this->password);
    // }
    // else
    // {
    //     LV_LOG_TRACE("no SSID or password stored");
    //     //Set first character to \0 indicates an empty string
    //     this->SSID[0] = '\0';
    //     this->password[0] = '\0';
    //     WiFi.disconnect();
    // }
    // Attempt Connection with stored Credentials
    // if( !wifiEnabled ) {
    //   LV_LOG_TRACE("WiFi not enabled");
    // } else if (!ssid.isEmpty() ) {
    //   this->connect(ssid.c_str(), password.c_str());
    // } else {
    //   LV_LOG_TRACE("no SSID or password stored");
    //   WiFi.disconnect();
    // }

    WiFi.setSleep(true);
  LV_LOG_TRACE("<<< WifiHandler::begin()");
}

// void WifiHandler::connect(const char* SSID, const char* password)
// {
//     LV_LOG_TRACE("ssid: \"%s\", password: \"%s\"", SSID, password);
//     temporary_password = password;
//     temporary_ssid = SSID;
//     WiFi.begin(SSID, password);
//     LV_LOG_TRACE("finished");
// }
void WifiHandler::connect(std::string ssid, std::string password) {
    Serial.printf("Attempting Wifi Connection To %s \n", ssid.c_str());
    mIsConnectionAttempt = true;
    mConnectionAttemptPassword = password;
    mConnectionAttemptSSID = ssid;
    auto status = WiFi.begin(mConnectionAttemptSSID.c_str(),
                              mConnectionAttemptPassword.c_str());
}

void WifiHandler::turnOff()
{
  WiFi.disconnect();
  WiFi.mode(WIFI_OFF);

  // Preferences preferences;
  // preferences.begin("wifiSettings", false);
  // preferences.putBool("enabled", false);
  // preferences.end();
}

bool WifiHandler::isConnected()
{
    return WiFi.isConnected();
}

std::string WifiHandler::getSSID()
{
    //return this->SSID;
    return mSSID;
}

std::string WifiHandler::getIP()
{
    return (WiFi.localIP().toString()).c_str();
}